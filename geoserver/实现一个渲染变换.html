<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> GeoServer 实现一个渲染变换(Rendering Transformation) · yatsov的博客</title><meta name="description" content="GeoServer 实现一个渲染变换(Rendering Transformation) - yatsov"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yatsov.github.io/atom.xml" title="yatsov的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">目录</a></li><li class="nav-list-item"><a href="/categories/index.html" target="_self" class="nav-list-link">分类</a></li><li class="nav-list-item"><a href="https://github.com/yatsov/yatsov.github.io" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/index.html" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/work/index.html" target="_self" class="nav-list-link">作品</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">GeoServer 实现一个渲染变换(Rendering Transformation)</h1><div class="post-info">2018年8月11日</div><div class="post-content"><h1 id="实现一个渲染变换-Rendering-Transformation"><a href="#实现一个渲染变换-Rendering-Transformation" class="headerlink" title="实现一个渲染变换(Rendering Transformation)"></a>实现一个渲染变换(Rendering Transformation)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>渲染转换是一种特殊的WPS过程，它运行在Geoserver WMS渲染管道中，对数据进行转换，以提供更有效的可视化。本节介绍如何在Java中实现呈现转换过程</p>
</blockquote>
<p>呈现转换非常通用，可以转换输入数据的内容和格式。内容转换通常涉及复杂的地理空间处理，需要访问整个数据集(与几何转换不同，几何学转换一次只对单个空间特征进行操作)。格式转换从矢量转换到栅格，反之亦然，以产生适合于所需可视化的输出格式(例如，用于显示连续曲面的瓦片，或用于显示离散对象的矢量数据)。</p>
<p>有关Geoserver中渲染转换功能的更多信息，请参阅Geoserver用户指南的渲染转换部分。</p>
<h2 id="渲染转换的生命周期"><a href="#渲染转换的生命周期" class="headerlink" title="渲染转换的生命周期"></a>渲染转换的生命周期</h2><p>要实现渲染转换，首先就要了解它在GeoServer中的生命周期以及执行的操作。一个渲染转换是在SLD中通过在<featuretypestyle>要素中声明 <transformation>要素完成的。这个元素(<transformation>)生命了转换过程的名称和值以及渲染参数。<br>下面是实现gs:Heatmap转换在SLD中声明的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;FeatureTypeStyle&gt;</span><br><span class="line">           &lt;Transformation&gt;</span><br><span class="line">             &lt;ogc:Function name=&quot;gs:Heatmap&quot;&gt;</span><br><span class="line">               &lt;ogc:Function name=&quot;parameter&quot;&gt;</span><br><span class="line">                 &lt;ogc:Literal&gt;data&lt;/ogc:Literal&gt;</span><br><span class="line">               &lt;/ogc:Function&gt;</span><br><span class="line">               &lt;ogc:Function name=&quot;parameter&quot;&gt;</span><br><span class="line">                 &lt;ogc:Literal&gt;weightAttr&lt;/ogc:Literal&gt;</span><br><span class="line">                 &lt;ogc:Literal&gt;pop2000&lt;/ogc:Literal&gt;</span><br><span class="line">               &lt;/ogc:Function&gt;</span><br><span class="line">               &lt;ogc:Function name=&quot;parameter&quot;&gt;</span><br><span class="line">                 &lt;ogc:Literal&gt;radiusPixels&lt;/ogc:Literal&gt;</span><br><span class="line">                 &lt;ogc:Function name=&quot;env&quot;&gt;</span><br><span class="line">                   &lt;ogc:Literal&gt;radius&lt;/ogc:Literal&gt;</span><br><span class="line">                   &lt;ogc:Literal&gt;100&lt;/ogc:Literal&gt;</span><br><span class="line">                 &lt;/ogc:Function&gt;</span><br><span class="line">               &lt;/ogc:Function&gt;</span><br><span class="line">               &lt;ogc:Function name=&quot;parameter&quot;&gt;</span><br><span class="line">                 &lt;ogc:Literal&gt;pixelsPerCell&lt;/ogc:Literal&gt;</span><br><span class="line">                 &lt;ogc:Literal&gt;10&lt;/ogc:Literal&gt;</span><br><span class="line">               &lt;/ogc:Function&gt;</span><br><span class="line">               &lt;ogc:Function name=&quot;parameter&quot;&gt;</span><br><span class="line">                 &lt;ogc:Literal&gt;outputBBOX&lt;/ogc:Literal&gt;</span><br><span class="line">                 &lt;ogc:Function name=&quot;env&quot;&gt;</span><br><span class="line">                   &lt;ogc:Literal&gt;wms_bbox&lt;/ogc:Literal&gt;</span><br><span class="line">                 &lt;/ogc:Function&gt;</span><br><span class="line">               &lt;/ogc:Function&gt;</span><br><span class="line">               &lt;ogc:Function name=&quot;parameter&quot;&gt;</span><br><span class="line">                 &lt;ogc:Literal&gt;outputWidth&lt;/ogc:Literal&gt;</span><br><span class="line">                 &lt;ogc:Function name=&quot;env&quot;&gt;</span><br><span class="line">                   &lt;ogc:Literal&gt;wms_width&lt;/ogc:Literal&gt;</span><br><span class="line">                 &lt;/ogc:Function&gt;</span><br><span class="line">               &lt;/ogc:Function&gt;</span><br><span class="line">               &lt;ogc:Function name=&quot;parameter&quot;&gt;</span><br><span class="line">                 &lt;ogc:Literal&gt;outputHeight&lt;/ogc:Literal&gt;</span><br><span class="line">                 &lt;ogc:Function name=&quot;env&quot;&gt;</span><br><span class="line">                   &lt;ogc:Literal&gt;wms_height&lt;/ogc:Literal&gt;</span><br><span class="line">                 &lt;/ogc:Function&gt;</span><br><span class="line">               &lt;/ogc:Function&gt;</span><br><span class="line">             &lt;/ogc:Function&gt;</span><br><span class="line">           &lt;/Transformation&gt;</span><br></pre></td></tr></table></figure></transformation></transformation></featuretypestyle></p>
<p>在WMS请求中我们使用SLD来指定变换，所有的参数都是在SLD文档中指定的参数。一些参数值必须由SLD变量指定。参考上图。<br>在执行转换过程之前，可以通过可选的反向查询(invertQuery)或invertGridGeometry方法，将查询Geoserver所做的查询重写到源数据存储。这允许转换扩大查询范围，因为某些类型的转换可能需要包含位于原始查询窗口之外的数据。渲染变换是可以扩大查询范围的，因为某些类型的转换可能需要包含位于原始查询数据之外的数据。</p>
<p>然后对源数据存储执行查询，并对结果数据集执行转换过程。转换返回的数据集要么格式相同要么格式不同。如果坐标系和需求不一样还会被自动转换。最后，输出数据集通过渲染管道传递，由SLD的<featuretypestyle>中定义的符号符进行样式设置。</featuretypestyle></p>
<h2 id="转换过程类-Transformation-process-class"><a href="#转换过程类-Transformation-process-class" class="headerlink" title="转换过程类 (Transformation process class)"></a>转换过程类 (Transformation process class)</h2><p>和其它WPS过程类似，渲染转换的实现也是通过Java类的。一个服务过程(process)需要实现<strong>GSProcess marker</strong>接口。并且需要通过applicationContext.xml文件来注册到GeoServer中。另外如果需要了解更多关于如果构建以及如何注册等信息请参阅WPS服务构建章节(上一篇哦)。</p>
<p>WPS服务必须提供关于这个服务的元数据以及参数。最简单的方法是使用GeoTools annotation-based Process API,它使用了Java注解来指定元数据。例如，下面的代码展示了渲染变换(gs:Heatmap)元数据指定的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@DescribeProcess(title = &quot;Heatmap&quot;,</span><br><span class="line">             description = &quot;Computes a heatmap surface over a set of irregular data points as a GridCoverage.&quot;)</span><br><span class="line">public class HeatmapProcess implements GeoServerProcess &#123;</span><br></pre></td></tr></table></figure>
<p>GeoServer对于每个渲染变换实现单个实例。这意味着呈现转换类必须是无状态的，使得我们可以通过调用他们来处理不同的请求。这是通过避免在类中声明任何实例变量来确保的。对于复杂的转换，可能需要实现一个辅助类，以允许使用实例变量。</p>
<blockquote>
<p>译者注：这里面的意思应该是每个WPS服务实现都是有一个类不会，那么在多线程情况下，如果里面有变量可能会是线程不安全的，所以变量建议通过别的类来存储，这样避免变量串了。</p>
</blockquote>
<h2 id="执行方法-execute-method"><a href="#执行方法-execute-method" class="headerlink" title="执行方法(execute method)"></a>执行方法(execute method)</h2><p>像所有的服务过程类(process classes)一样，一个渲染转换类必须实现一个执行方法，来教会GeoServer如何执行转换。执行方法的签名(DescribeResult、DescribeParameter)指定输入参数的类型和过程结果。</p>
<p>一个Heatmap变换的执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@DescribeResult(name = &quot;result&quot;, description = &quot;The heat map surface as a raster&quot;)</span><br><span class="line">public GridCoverage2D execute(</span><br><span class="line"></span><br><span class="line">  // tranformation input data</span><br><span class="line">  @DescribeParameter(name = &quot;data&quot;, description = &quot;Features containing the data points&quot;)</span><br><span class="line">    SimpleFeatureCollection obsFeatures,</span><br><span class="line"></span><br><span class="line">  // process parameters</span><br><span class="line">  @DescribeParameter(name = &quot;radiusPixels&quot;,</span><br><span class="line">                     description = &quot;Radius to use for the kernel, in pixels&quot;)</span><br><span class="line">    Integer argRadiusPixels,</span><br><span class="line">  @DescribeParameter(name = &quot;weightAttr&quot;,</span><br><span class="line">              description = &quot;Featuretype attribute containing the point weight value&quot;,</span><br><span class="line">                     min = 0, max = 1)</span><br><span class="line">     String valueAttr,</span><br><span class="line">  @DescribeParameter(name = &quot;pixelsPerCell&quot;,</span><br><span class="line">                     description = &quot;Number of pixels per grid cell (default = 1)&quot;,</span><br><span class="line">                     min = 0, max = 1)</span><br><span class="line">    Integer argPixelsPerCell,</span><br><span class="line"></span><br><span class="line">  // output map parameters</span><br><span class="line">  @DescribeParameter(name = &quot;outputBBOX&quot;,</span><br><span class="line">                     description = &quot;Georeferenced bounding box of the output&quot;)</span><br><span class="line">    ReferencedEnvelope argOutputEnv,</span><br><span class="line">  @DescribeParameter(name = &quot;outputWidth&quot;, description = &quot;Width of the output raster&quot;)</span><br><span class="line">    Integer argOutputWidth,</span><br><span class="line">  @DescribeParameter(name = &quot;outputHeight&quot;, description = &quot;Height of the output raster&quot;)</span><br><span class="line">    Integer argOutputHeight,</span><br><span class="line"></span><br><span class="line">  ) throws ProcessException &#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h2 id="输入参数-Input-parameters"><a href="#输入参数-Input-parameters" class="headerlink" title="输入参数(Input parameters)"></a>输入参数(Input parameters)</h2><p>一个受支持的输入参数是通过execute方法的参数传入的。元数据则是通过@DescribeParameter注解获取的。</p>
<p>要接受要转换的输入数据，过程必须定义一个输入参数，类型为SimpleFeatureCollection或GridCoverage2D。在GeoServer支持数据作为参数传入，来执行过程，但是需要指定上面所说的参数。可以定义任意数量的其他参数。参数可以是强制性的，也可以是可选的(如果不存在，可选参数的值为NULL)。可以通过定义数组值参数来接受值列表.</p>
<p>有些转换需要有关请求地图的范围和坐标系统的信息，并要求图像的宽度和高度。这些需要的情况包括：</p>
<p>1、转换操作依赖请求分辨率;<br>2、转换操作计算的是一个栅格结果，需要目标坐标系来达到一个最佳效果；</p>
<p>这些值可以从SLD预定义变量中获得，并通过ReferencedEncrype和Integer类型的参数传入。(有关所有可用预定义变量的详细信息，请参阅“用户指南”中的SLD部分中的变量替换。)</p>
<p>在Heatmap变换的情况下，请求分辨率会被用于整个数据范围内的像素半径参数，另外输出栅格也会在需要的坐标系下进行计算避免不被期望的投影。</p>
<p>为了支持这个变换需要定义outputBBOX、outputWidth以及outputHeight参数。这些是由预定义的SLD变量提供的，如上面SLD片段。</p>
<h2 id="变换输出-Transformation-output"><a href="#变换输出-Transformation-output" class="headerlink" title="变换输出(Transformation output)"></a>变换输出(Transformation output)</h2><p>变换的输出是一个新的( SimpleFeatureCollection 或者 GridCoverage2D类型的)数据集,返回类型需要在execute的返回类型中指定。名称以及元数据由execute方法的@DescribeResult注解负责提供。</p>
<p>如果输出数据集数据的坐标系与地图输出的坐标系不符，GeoServer将会自己动调整坐标。另外我们可以通过设置请求坐标系来解决避免自动转换（一定要明确坐标系）。</p>
<h2 id="查询重写-Query-rewriting"><a href="#查询重写-Query-rewriting" class="headerlink" title="查询重写(Query rewriting)"></a>查询重写(Query rewriting)</h2><p>如果需要，渲染转换有能力改变对源数据集的查询。允许扩展要读取的数据的范围，对于某些类型的转换（特别是通过计算围绕输入的空间窗口来确定结果的那些）是必要的。这也允许控制查询优化（例如，确保几何抽取不阻止点特征被读取）。</p>
<blockquote>
<p>译者注：我的理解就是读取的范围可以扩大或者精炼。</p>
</blockquote>
<p>查询重写是通过提供InvertQuery或invertGridGeometry方法来实现的。这些方法的一般签名是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">X invertX( [inputParam,]* Query targetQuery, GridGeometry targetGridGeometry)</span><br></pre></td></tr></table></figure></p>
<p>targetQuery参数是请求的查询构造体。</p>
<p>targetGridGeometry是被请求的输出地图的地理参考范围。他不会被用在数据查询汇总，但可能需要与转换参数一起使<br>用，以确定如何重写查询。例如，如果在输出单元中指定了参数，那么输出范围信息将该值转换为与输入CRS相适应的值。</p>
<blockquote>
<p>自己实现？</p>
</blockquote>
<p>此外，这些方法可以接受为执行方法定义的任意数量的输入参数。如果定义了这些参数，他们也必须通过@DescribeParameter参数在execute中进行注解。</p>
<h2 id="invertQuery方法"><a href="#invertQuery方法" class="headerlink" title="invertQuery方法"></a>invertQuery方法</h2><p>这个方法会在渲染变换处理矢量数据是调用（输入数据的类型是SimpleFeatureCollection）。</p>
<p>这个方法会返回一个新的查询值，包含了范围或查询优化所需的任何更改。它被用于查询资源数据集。</p>
<p>热力图渲染过程实现了invertQuery来增大查询范围。这个查询范围则是通过与radiusPixels参数相关的ground size决定的。</p>
<blockquote>
<p>The Heatmap process implements the invertQuery method in order to enlarge the query extent by the ground size corresponding to the radiusPixels parameter.<br>这句ground size是啥？</p>
</blockquote>
<p>为了允许将像素尺寸转换为ground distance，还需要提供输出地图范围的输入参数。所实现的方法的签名是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Query invertQuery(</span><br><span class="line">        @DescribeParameter(name = &quot;radiusPixels&quot;,</span><br><span class="line">                       description = &quot;Radius to use for the kernel&quot;, min = 0, max = 1)</span><br><span class="line">          Integer argRadiusPixels,</span><br><span class="line">        // output image parameters</span><br><span class="line">        @DescribeParameter(name = &quot;outputBBOX&quot;,</span><br><span class="line">                       description = &quot;Georeferenced bounding box of the output&quot;)</span><br><span class="line">          ReferencedEnvelope argOutputEnv,</span><br><span class="line">        @DescribeParameter(name = &quot;outputWidth&quot;,</span><br><span class="line">                       description = &quot;Width of the output raster&quot;)</span><br><span class="line">          Integer argOutputWidth,</span><br><span class="line">        @DescribeParameter(name = &quot;outputHeight&quot;,</span><br><span class="line">                       description = &quot;Height of the output raster&quot;)</span><br><span class="line">          Integer argOutputHeight,</span><br><span class="line"></span><br><span class="line">        Query targetQuery, GridGeometry targetGridGeometry</span><br><span class="line">   ) throws ProcessException &#123;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<h2 id="invertGridGeometry-方法"><a href="#invertGridGeometry-方法" class="headerlink" title="invertGridGeometry 方法"></a>invertGridGeometry 方法</h2><p>这个方法会在渲染栅格数据时（输入格式是GridCoverage2D）时被调用。该方法返回一个新的GridGeometry值，用作对源栅格数据集的查询范围。</p>
<h2 id="在总结"><a href="#在总结" class="headerlink" title="在总结"></a>在总结</h2><p>总结一下 ，渲染变换的重点是:</p>
<p>1、再输入的时候必须有个输入参数是FeatureCollection或者GridCoverage2D。<br>2、在输入参数中包含地图范围和图像尺寸是很有用的。<br>3、输出是必须有单一一个输出结果是FeatureCollection类型或者GridCoverage2D类型。<br>4、invertQuery和invertGridGeometry方法为可选项，可以被提供来重写数据查询。<br>5、注意渲染变换代码的无状态问题。</p>
</div></article></div></main><footer><div class="paginator"><a href="/geoserver/样式.html" class="prev">上一篇</a><a href="/gis/GeoServer如何发布一个WPS服务.html" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2018 <a href="http://yatsov.github.io">yatsov</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>