<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> GeTools中的JTS基础 · yatsov的博客</title><meta name="description" content="GeTools中的JTS基础 - yatsov"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yatsov.github.io/atom.xml" title="yatsov的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">目录</a></li><li class="nav-list-item"><a href="/categories/index.html" target="_self" class="nav-list-link">分类</a></li><li class="nav-list-item"><a href="https://github.com/yatsov/yatsov.github.io" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/index.html" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/work/index.html" target="_self" class="nav-list-link">作品</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">GeTools中的JTS基础</h1><div class="post-info">2018年4月21日</div><div class="post-content"><p>介绍JTS的使用,是对GeoTools的一个翻译。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>以下文档是我对Geotools的翻译和理解，因为JTS的文档并不是那么全，希望大家受益。</p>
</blockquote>
<p>JTS拓扑套件是一个GeoTools的外部套件来提供一个地理信息数据结构的实现。主要的好处就是经过多年的努力在数值上是稳定的。<br>GooToots都是关于实现空间解决方案的，我们尽最大努力遵循一个不自己疯狂造轮子的主旨。优秀的JTS拓扑套件项目提供了我们在整个库中使用的几何实现。</p>
<p>GeoTools中提供了一些组件辅助JTS<br>1  <strong>gt-api</strong> 提供了帮助类和扩展JTS的CurvedGeometryFactory工厂来处理弧线。<br>2  <strong>gt-main</strong> 提供了帮助类来讲Geometry转换为Java形态展示。</p>
<h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><p><a href="http://sourceforge.net/projects/jts-topo-suite/" target="_blank" rel="noopener">jts-topo-suite</a><br><a href="http://tsusiatsoftware.net/jts/main.html" target="_blank" rel="noopener">http://tsusiatsoftware.net/jts/main.html</a><br><a href="http://www.vividsolutions.com/jts/bin/JTS%20Developer%20Guide.pdf" target="_blank" rel="noopener">http://www.vividsolutions.com/jts/bin/JTS%20Developer%20Guide.pdf</a><br><a href="http://www.vividsolutions.com/jts/bin/JTS%20Technical%20Specs.pdf" target="_blank" rel="noopener">http://www.vividsolutions.com/jts/bin/JTS%20Technical%20Specs.pdf</a></p>
<h2 id="Maven-坐标"><a href="#Maven-坐标" class="headerlink" title="Maven 坐标"></a>Maven 坐标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.vividsolutions&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jts&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.13&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h2><p>我们使用JTS的GeometryFactory来创建Geometry对象。GeometryFactory有许多的创建方法能够让坐标实例被包裹进合适的Geometry中。<br>用于检索SQL标准的简单OGC要素是由Point, LineString and Polygon实现的。</p>
<p><img src="http://112.74.52.111/geotools/geotools-18.3/_images/geometry.png" alt=""></p>
<p>每一个Geometry可以被一个Envelope(外包框)包围。OGC简单要素的对于SQL标准的实现同样也收GeometryCollections的支持。GeometryCollections其中自己包含着Geometry。</p>
<p><img src="http://112.74.52.111/geotools/geotools-18.3/_images/geometry_collection.png" alt=""></p>
<p>你可以实现你自己的GeometryFactory通过一个指定的PrecisionModel和一个CoordinateSequenceFactory。</p>
<p><img src="http://112.74.52.111/geotools/geotools-18.3/_images/geometry_factory.png" alt=""></p>
<blockquote>
<p>如果您需要考虑坐标的存储方式(可能是floats而不是doubles)，这些“高级”配置选项您应该会感兴趣。这两个概念一起工作：如果将坐标存储在浮点数数组中，那么JTS只需要在计算过程中考虑浮动精度。（此处不理解，我的理解是用什么存储系统下面的就是用什么，可能还需要看看源码）</p>
</blockquote>
<p>GeometryFactory 工作的很好（可能意思是可以少考虑点底层）。</p>
<p>GeoTools扩展了这些Geometry类来支持曲线。这些实现生成坐标能够让他们像正常的JTS实现一样。</p>
<p><img src="http://112.74.52.111/geotools/geotools-18.3/_images/geometry2.png" alt=""></p>
<p>用于生成坐标的线性化过程利用了定义曲线的控制点和CurvedGetimeyFactory提供的容差。</p>
<h3 id="建立一个点-Creating-a-Point"><a href="#建立一个点-Creating-a-Point" class="headerlink" title="建立一个点 Creating a Point"></a>建立一个点 Creating a Point</h3><p>下面我们使用JTS GeometryFactory来建立一个点，下面是使用FactoryFinder的一个标准实例。</p>
<blockquote>
<p>如果您对精度有要求可以自己搞起。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory();</span><br><span class="line">  </span><br><span class="line">Coordinate coord = new Coordinate(1, 1);</span><br><span class="line">Point point = geometryFactory.createPoint(coord);</span><br></pre></td></tr></table></figure>
<p>这里也支持WKT字符串创建 ，WKT字符串是SQL标准定义的一个实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory();</span><br><span class="line">    </span><br><span class="line">WKTReader reader = new WKTReader(geometryFactory);</span><br><span class="line">Point point = (Point) reader.read(&quot;POINT (1 1)&quot;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果您需要多个点，可以使用MultiPoint</p>
</blockquote>
<h3 id="创造一个线-Creating-a-LineString"><a href="#创造一个线-Creating-a-LineString" class="headerlink" title="创造一个线 Creating a LineString"></a>创造一个线 Creating a LineString</h3><p><img src="http://112.74.52.111/geotools/geotools-18.3/_images/geometry_linestring.png" alt=""></p>
<p>下面的代码用于创造线:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory();</span><br><span class="line">Coordinate[] coords  =</span><br><span class="line"> new Coordinate[] &#123;new Coordinate(0, 2), new Coordinate(2, 0), new Coordinate(8, 6) &#125;;</span><br><span class="line">LineString line = geometryFactory.createLineString(coordinates);</span><br></pre></td></tr></table></figure>
<p>或者是使用WKT字符串搞定这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory();</span><br><span class="line"></span><br><span class="line">WKTReader reader = new WKTReader( geometryFactory );</span><br><span class="line">LineString line = (LineString) reader.read(&quot;LINESTRING(0 2, 2 0, 8 6)&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果线不连续可以考虑MultiLineString。</p>
</blockquote>
<h3 id="创建一个多边形"><a href="#创建一个多边形" class="headerlink" title="创建一个多边形"></a>创建一个多边形</h3><p><img src="http://112.74.52.111/geotools/geotools-18.3/_images/geometry_polygon.png" alt=""><br>示例代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory();</span><br><span class="line"></span><br><span class="line">Coordinate[] coords  =</span><br><span class="line">   new Coordinate[] &#123;new Coordinate(4, 0), new Coordinate(2, 2),</span><br><span class="line">                     new Coordinate(4, 4), new Coordinate(6, 2), new Coordinate(4, 0) &#125;;</span><br><span class="line"></span><br><span class="line">LinearRing ring = geometryFactory.createLinearRing( coords );</span><br><span class="line">LinearRing holes[] = null; // use LinearRing[] to represent holes</span><br><span class="line">Polygon polygon = geometryFactory.createPolygon(ring, holes );</span><br></pre></td></tr></table></figure></p>
<p>或者是从WKT字符串解决:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory( null );</span><br><span class="line"></span><br><span class="line">WKTReader reader = new WKTReader( geometryFactory );</span><br><span class="line">Polygon polygon = (Polygon) reader.read(&quot;POLYGON((20 10, 30 0, 40 10, 30 20, 20 10))&quot;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>您可以使用MultiPolygon 表达洞，另外可以运用它表达您想要的形状。</p>
</blockquote>
<h3 id="Creating-CircularString-创建一个环"><a href="#Creating-CircularString-创建一个环" class="headerlink" title="Creating CircularString 创建一个环"></a>Creating CircularString 创建一个环</h3><p>When setting up a CurvedGeometryFactory the provided tolerance will be used during linearization:<br>请使用<strong>GeoTools CurvedGeometryFactory</strong>来创建环。在线性化过程中将会使用提供的容差。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory();</span><br><span class="line">CurvedGeometryFactory curvedFactory = new CurvedGeometryFactory(geometryFactory,Double.MAX_VALUE);</span><br><span class="line">PackedCoordinateSequence coords = new PackedCoordinateSequence.Double(</span><br><span class="line">       new double[]&#123;10,14,6,10,14,10&#125;, 2 );</span><br><span class="line">CircularString arc = (CircularString) curvedFactory.createCurvedGeometry(coords);</span><br></pre></td></tr></table></figure></p>
<p>上面的圆弧应该看做10,14 6,10 14,10（参照WKT字符串）。上面的例子使用PackedCoordinateSequence来压入一串坐标数据。曲线（Curve）支持二维坐标。如果两个或者多个curves从一个闭环中被提供那么就会返回一个CircularLineString。</p>
<p>从WKT字符串中读取圆环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory();</span><br><span class="line">CurvedGeometryFactory curvedfactory = new CurvedGeometryFactory(Double.MAX_VALUE);   </span><br><span class="line">WKTReader2 reader = new WKTReader2(curvedfactory);</span><br><span class="line">CircularString arc = (CircularString) reader.read(&quot;CIRCULARSTRING(10 14,6 10,14 10)&quot;);</span><br></pre></td></tr></table></figure></p>
<p>一个CompoundCurve(或者闭合的CompoundRing)包括一个CircularString的融合或者一个普通的LineString组件。</p>
<h3 id="创建一个自定义曲线-Custom-Curves"><a href="#创建一个自定义曲线-Custom-Curves" class="headerlink" title="创建一个自定义曲线 Custom Curves"></a>创建一个自定义曲线 Custom Curves</h3><p>JTS拓扑套件没有一个结构用来表示曲线(curve)和圆(circle)。GeoTools添加了一个扩展。JTS所使用的数学严格限于由直线(即直线)组成的几何学。</p>
<p>GeoTools的曲线实现依靠着使用控制点来定义曲线，并在最后可能的时刻（ the last possible moment）将其转换为直线。(这里需要看代码)</p>
<p>Curves也可以使用一些数学方法手工达成。</p>
<h4 id="创建一个圆"><a href="#创建一个圆" class="headerlink" title="创建一个圆"></a>创建一个圆</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static Geometry createCircle(double x, double y, final double RADIUS) &#123;</span><br><span class="line">  GeometricShapeFactory shapeFactory = new GeometricShapeFactory();</span><br><span class="line">  shapeFactory.setNumPoints(32);</span><br><span class="line">  shapeFactory.setCentre(new Coordinate(x, y));</span><br><span class="line">  shapeFactory.setSize(RADIUS * 2);</span><br><span class="line">  return shapeFactory.createCircle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码其实没有特殊之处，他的想法就是创建一系列坐标逼近圆形。</p>
<p>另外一种方法是用java的handy Shape classes创建一个曲线或者shape对象然后从该对象中提取坐标来创建你想要的geometry。</p>
<p>不使用数学方法创建Arcs:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static Geometry createBezierCurve(Coordinate start,</span><br><span class="line">                                          Coordinate end,</span><br><span class="line">                                          Coordinate ctrlPoint1,</span><br><span class="line">                                          Coordinate ctrlPoint2</span><br><span class="line">                                          double smooth) &#123;</span><br><span class="line">    Shape curve = new CubicCurve2D.Double(</span><br><span class="line">        start.x, start.y,</span><br><span class="line">        ctrlPoint1.x, ctrlPoint1.y,</span><br><span class="line">        ctrlPoint2.x, ctrlPoint2.y,</span><br><span class="line">        end.x, end.y);</span><br><span class="line"></span><br><span class="line">    // the value of the smooth arg determines how closely the line</span><br><span class="line">    // segments between points approximate the smooth curve</span><br><span class="line">    // (see javadocs for Shape.getPathIterator method)</span><br><span class="line"></span><br><span class="line">    PathIterator iter = curve.getPathIterator(null, smooth);</span><br><span class="line"></span><br><span class="line">    // a length 6 array is required for the iterator</span><br><span class="line">    double[] iterBuf = new double[6];</span><br><span class="line"></span><br><span class="line">    List&lt;Coordinate&gt; coords = new ArrayList&lt;Coordinate&gt;();</span><br><span class="line">    while (!iter.isDone()) &#123;</span><br><span class="line">        iter.currentSegment(iterBuf);</span><br><span class="line">        coords.add(new Coordinate(buf[0], buf[1]);</span><br><span class="line">        iter.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GeometryFactory gf = new GeometryFactory();</span><br><span class="line">    return gf.createLineString(coords.toArray(new Coordinate[coords.size()]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一群随机生成的弧线:<br><img src="http://112.74.52.111/geotools/geotools-18.3/_images/geometry_curve.gif" alt=""></p>
<p>有时候你想建立一个曲线并且是能够穿过某些指定点的支线。这里建议您使用样条函数。这就产生了一组多项式(三次)曲线，每一条曲线都符合数据的一部分，并且平滑地连接到它的相邻曲线。<br>Splines(样条函数)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public Geometry splineInterpolatePoints(double[] xPoints, double[] yPoints) &#123;</span><br><span class="line">   /*</span><br><span class="line">   * First we create a LineString of segments with the</span><br><span class="line">   * input points as vertices.</span><br><span class="line">   */</span><br><span class="line">   final int N = xPoints.length;</span><br><span class="line">   Coordinate[] coords = new Coordinate[N];</span><br><span class="line">   for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">      coords[i] = new Coordinate(xPoints[i], yPoints[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   GeometryFactory gf = new GeometryFactory();</span><br><span class="line">   LineString line = gf.createLineString(coords);</span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">   * Now we use the GeoTools JTS utility class to smooth the</span><br><span class="line">   * line. The returned Geometry will have all of the vertices</span><br><span class="line">   * of the input line plus extra vertices tracing a spline</span><br><span class="line">   * curve. The second argument is the &apos;fit&apos; parameter which</span><br><span class="line">   * can be in the range 0 (loose fit) to 1 (tightest fit).</span><br><span class="line">   */</span><br><span class="line">   return JTS.smooth(line, 0.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于多边形的平滑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WKTReader reader = new WKTReader();</span><br><span class="line">Geometry tShape = reader.read(</span><br><span class="line">&quot;POLYGON((10 0, 10 20, 0 20, 0 30, 30 30, 30 20, 20 20, 20 0, 10 0))&quot;);</span><br><span class="line"></span><br><span class="line">Geometry tLoose = JTS.smooth(tShape, 0.0);</span><br><span class="line">Geometry tTighter = JTS.smooth(tShape, 0.75);</span><br></pre></td></tr></table></figure></p>
<p>结果:<br><img src="http://112.74.52.111/geotools/geotools-18.3/_images/geometry_spline2.png" alt=""></p>
<h3 id="Geometry-1"><a href="#Geometry-1" class="headerlink" title="Geometry"></a>Geometry</h3><p>使用Geometry很直接但是，当方法很多了也不太好。<br><img src="http://112.74.52.111/geotools/geotools-18.3/_images/geometry_use.PNG" alt=""><br>Some summary information is available:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getArea() - area returned in the same units as the coordinates (be careful of lat/lon data!)</span><br><span class="line">getCentroid() - the centre of the geometry</span><br><span class="line">getEnvelope() - returns a geometry which is probably not what you wanted</span><br><span class="line">getEnvelopeInternal() - this returns a useful Envelope</span><br><span class="line">getInteriorPoint() - the centre of the geometry (that is actually on the geometry)</span><br><span class="line">getDimension()</span><br></pre></td></tr></table></figure></p>
<p>Geometry relationships are represented by the following functions returning true or false:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">disjoint(Geometry) - same as “not” intersects</span><br><span class="line">touches(Geometry) - geometry have to just touch, crossing or overlap will not work</span><br><span class="line">intersects(Geometry)</span><br><span class="line">crosses(Geometry)</span><br><span class="line">within(Geometry) - geometry has to be full inside</span><br><span class="line">contains(Geometry)</span><br><span class="line">overlaps(Geometry) - has to actually overlap the edge, being within or touching will not work</span><br><span class="line">covers(Geometry)</span><br><span class="line">coveredBy(Geometry)</span><br><span class="line">relate(Geometry, String) - allows general check of relationship see dim9 page</span><br><span class="line">relate(Geometry)</span><br></pre></td></tr></table></figure></p>
<p>To actually determine a shape based on two geometry:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intersection(Geometry)</span><br><span class="line">union(Geometry)</span><br><span class="line">difference(Geometry)</span><br><span class="line">symDifference(Geometry)</span><br></pre></td></tr></table></figure></p>
<p>Some of the most helpful functions are:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">distance( Geometry )</span><br><span class="line">buffer(double) - used to buffer the edge of a geometry to produce a polygon</span><br><span class="line">union() - used on a geometry collection to produce a single geometry</span><br></pre></td></tr></table></figure></p>
<p>The three most difficult methods are here (they will be discussed in detail):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equals( Object ) - normal Java equals which checks that the two objects are the same instance</span><br><span class="line">equals( Geometry ) - checks if the geometry is the same shape</span><br><span class="line">equalsExact( Geometry ) - check if the data structure is the same</span><br></pre></td></tr></table></figure></p>
<p>There are some book keeping methods to help discovery how the geometry was constructed:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getGeometryFactory()</span><br><span class="line">getPreceisionModel()</span><br><span class="line">toText() - the WKT representation of the Geometry</span><br><span class="line">getGeoemtryType() - factory method called (i.e. “point”, “linestring”, etc..)</span><br></pre></td></tr></table></figure></p>
<p>A couple of methods are there to store your developer information:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">getSRID() - stores the “spatial reference id”, used as an external key when working with databases</span><br><span class="line">getUserData() - intended to be used by developers, a best practice is to store a java.util.Map</span><br><span class="line"></span><br><span class="line">GeoTools will occasionally use this field to store a “srsName” or full CoordinateReferenceSystem.</span><br></pre></td></tr></table></figure>
<h3 id="Geometries-Enum"><a href="#Geometries-Enum" class="headerlink" title="Geometries Enum"></a>Geometries Enum</h3><p>用几何枚举来判断几何类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean hit(Point point, Geometry geometry) &#123;</span><br><span class="line">    final double MAX_DISTANCE = 0.001;</span><br><span class="line">    </span><br><span class="line">    switch (Geometries.get(geometry)) &#123;</span><br><span class="line">    case POINT:</span><br><span class="line">    case MULTIPOINT:</span><br><span class="line">    case LINESTRING:</span><br><span class="line">    case MULTILINESTRING:</span><br><span class="line">        // Test if p is within a threshold distance</span><br><span class="line">        return geometry.isWithinDistance(point, MAX_DISTANCE);</span><br><span class="line">        </span><br><span class="line">    case POLYGON:</span><br><span class="line">    case MULTIPOLYGON:</span><br><span class="line">        // Test if the polygonal geometry contains p</span><br><span class="line">        return geometry.contains(point);</span><br><span class="line">        </span><br><span class="line">    default:</span><br><span class="line">        // For simplicity we just assume distance check will work for other</span><br><span class="line">        // types (e.g. GeometryCollection) in this example</span><br><span class="line">        return geometry.isWithinDistance(point, MAX_DISTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="PrecisionModel-精度模型"><a href="#PrecisionModel-精度模型" class="headerlink" title="PrecisionModel 精度模型"></a>PrecisionModel 精度模型</h3><p>“开箱即用”JTS适用于默认的双精度模型。通过配置GeometryFactory的PrecisionModel可以允许你使用一个不同的分辨率。<br><strong>精度模型是数值计算的核心</strong>。当使用较大的值时，Java中内置的数学并不是非常精确。通过显式捕获PrecisionModel JTS中的”round-off”过程，JTS允许管理这类错误，并对工作的速度和准确性进行适当的权衡。</p>
<p>Round-off(例如 ：6.0000001)经常发生即使是双精度模型。尤其是你的工作坐标系数字很大并且离着原点很远。这里面其实也是根据需要，如果你的使用精度要求不那么高那么可以减小精度模型。</p>
<p>下面的代码</p>
<p>The following code example takes into account that the location being passed in was only supplied as a floating point value x/y.<br>我们通过GeometryFactory创建一个带有PrecisionModel参数的测试点来解决这个问题。测试点将被标记为具有一定的有限精度，所有JTS操作都将考虑到这一点。</p>
<p>有多种方式来指定精度模型，但是这里我们基于十进制数的位置个数来为坐标比较提供服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private boolean polyContains(Polygon poly, float x, float y, int numDecPlaces) &#123;</span><br><span class="line">  double scale = Math.pow(10, numDecPlaces);</span><br><span class="line">  PrecisionModel pm = new PrecisionModel(scale);</span><br><span class="line">  GeometryFactory gf = new GeometryFactory(pm);</span><br><span class="line"></span><br><span class="line">  Geometry testPoint = gf.createPoint(new Coordinate(x, y));</span><br><span class="line">  return poly.contains(testPoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用其他的许多限定来建立精度模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm = new PrecisionModel( PrecisionModel.Type.FIXED ); // fixed decimal point</span><br><span class="line">pm = new PrecisionModel( PrecisionModel.Type.FLOATING ); // for Java double</span><br><span class="line">pm = new PrecisionModel( PrecisionModel.Type.FLOATING_SINGLE ); // for Java float</span><br></pre></td></tr></table></figure></p>
<h3 id="CoordinateSequence"><a href="#CoordinateSequence" class="headerlink" title="CoordinateSequence"></a>CoordinateSequence</h3><p>你也许希望提供一个自定义的CoordinateSequenceFactory来减小内存使用使得程序更有效率。</p>
<p>程序内部的几何通常用Coordinate[]工作，但是许多被JTS所用的空间格式会将值存储在double[] or float[]这样的一维数组中，这样会效率更高。通过实现一个CoordinateSequenceFactorygeotools可以教会JTS如何来直接处理一些文件数据例如shapefile。</p>
<h3 id="源码示例"><a href="#源码示例" class="headerlink" title="源码示例"></a>源码示例</h3><p>在JTS中还有些源码示例，可以用做学习。</p>
</div></article></div></main><footer><div class="paginator"><a href="/gis/Openlayers与React结合.html" class="prev">PREV</a><a href="/arcobject/ArcGIS Server 的跨域 .html" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2018 <a href="http://yatsov.github.io">yatsov</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>